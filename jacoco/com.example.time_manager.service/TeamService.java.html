<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TeamService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">time-manager</a> &gt; <a href="index.source.html" class="el_package">com.example.time_manager.service</a> &gt; <span class="el_source">TeamService.java</span></div><h1>TeamService.java</h1><pre class="source lang-java linenums">package com.example.time_manager.service;

import com.example.time_manager.dto.team.TeamDto;
import com.example.time_manager.model.Team;
import com.example.time_manager.model.TeamMember;
import com.example.time_manager.model.User;
import com.example.time_manager.repository.TeamMemberRepository;
import com.example.time_manager.repository.TeamRepository;
import com.example.time_manager.repository.UserRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.persistence.EntityNotFoundException;
import jakarta.validation.Valid;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.security.access.AccessDeniedException;


import java.util.*;

/**
 * Business logic for Teams &amp; Members with role-based access:
 *
 * - ADMIN: - can list all teams (allTeams) - can create/update/delete teams -
 * can add/remove team members everywhere
 *
 * - MANAGER (global role) AND member of the target team: - can add/remove
 * members in that team
 *
 * - EMPLOYEE (or any authenticated member of the target team): - can view team
 * members of their own teams
 *
 * - &quot;MyTeams&quot;: teams where current user is a member (any role) -
 * &quot;MyManagedTeams&quot;: teams where current user is a member AND has global MANAGER
 * role
 *
 * Notes: - User.role is stored as JSON String (e.g.
 * [&quot;employee&quot;,&quot;manager&quot;,&quot;admin&quot;]) - User.id is a String UUID (CHAR(36))
 */
@Service
@Transactional
public class TeamService {

    private final TeamRepository teamRepo;
    private final TeamMemberRepository teamMemberRepo;
    private final UserRepository userRepo;

<span class="fc" id="L49">    private final ObjectMapper objectMapper = new ObjectMapper();</span>

    public TeamService(TeamRepository teamRepo,
            TeamMemberRepository teamMemberRepo,
<span class="fc" id="L53">            UserRepository userRepo) {</span>
<span class="fc" id="L54">        this.teamRepo = teamRepo;</span>
<span class="fc" id="L55">        this.teamMemberRepo = teamMemberRepo;</span>
<span class="fc" id="L56">        this.userRepo = userRepo;</span>
<span class="fc" id="L57">    }</span>

    /* ===================== Queries ===================== */
    /**
     * Public-ish list of teams (you can further restrict if needed).
     */
    public List&lt;Team&gt; findAll() {
<span class="fc" id="L64">        return teamRepo.findAll();</span>
    }

    /**
     * Find a team by ID or throw 404.
     */
    public Team findById(Long id) {
<span class="fc" id="L71">        return teamRepo.findById(id)</span>
<span class="fc" id="L72">                .orElseThrow(() -&gt; new EntityNotFoundException(&quot;Team not found: &quot; + id));</span>
    }

    /**
     * ADMIN-only: list all teams.
     */
    public List&lt;Team&gt; findAllForAdmin() {
<span class="fc" id="L79">        requireAdmin();</span>
<span class="fc" id="L80">        return teamRepo.findAll();</span>
    }

    /**
     * Teams where the current user is a member.
     */
    public List&lt;Team&gt; findTeamsOfCurrentUser() {
<span class="fc" id="L87">        String me = currentUserId();</span>
<span class="fc" id="L88">        List&lt;Long&gt; teamIds = teamMemberRepo.findTeamIdsByUserId(me);</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        return teamIds.isEmpty() ? List.of() : teamRepo.findAllById(teamIds);</span>
    }

    /**
     * Teams where the current user is a member and has global MANAGER role. (We
     * reuse &quot;myTeams&quot; and simply require the MANAGER role.)
     */
    public List&lt;Team&gt; findManagedByCurrentUser() {
<span class="fc" id="L97">        requireRole(&quot;MANAGER&quot;);</span>
<span class="fc" id="L98">        return findTeamsOfCurrentUser();</span>
    }

    /**
     * List members of a given team. Allowed for ADMIN or any user who is a
     * member of that team.
     */
    public List&lt;User&gt; listMembers(Long teamId) {
<span class="fc" id="L106">        assertCanViewTeamMembers(teamId);</span>
<span class="fc" id="L107">        return teamMemberRepo.findUsersByTeamId(teamId);</span>
    }
    
    /**
     * Among a team's members, return the ones whose global role contains
     * &quot;manager&quot;.
     */
    public List&lt;User&gt; listTeamManagers(Long teamId) {
<span class="fc" id="L115">        assertCanViewTeamMembers(teamId);</span>
<span class="fc" id="L116">        List&lt;User&gt; members = teamMemberRepo.findUsersByTeamId(teamId);</span>
<span class="fc" id="L117">        return members.stream().filter(u -&gt; hasGlobalRole(u, &quot;manager&quot;)).toList();</span>
    }
    public boolean isCurrentUserMemberOfTeam(Long teamId) {
<span class="fc" id="L120">    return isMemberOf(teamId, currentUserId());</span>
    }

    /* ===================== Mutations ===================== */
    /**
     * Create a team. ADMIN-only by default.
     */
    public Team create(@Valid TeamDto dto) {
<span class="fc" id="L128">        requireAdmin();</span>
<span class="fc" id="L129">        Team t = new Team();</span>
<span class="fc" id="L130">        t.setName(dto.getName());</span>
<span class="fc" id="L131">        t.setDescription(dto.getDescription());</span>
<span class="fc" id="L132">        return teamRepo.save(t);</span>
    }

    /**
     * Update a team. ADMIN-only by default. If you want to allow MANAGER
     * members to update name/description, relax this check accordingly (e.g.,
     * assertCanManageTeamMembers(id)).
     */
    public Team update(Long id, @Valid TeamDto dto) {
<span class="fc" id="L141">        requireAdmin();</span>
<span class="fc" id="L142">        Team t = findById(id);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (dto.getName() != null) {</span>
<span class="fc" id="L144">            t.setName(dto.getName());</span>
        }
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (dto.getDescription() != null) {</span>
<span class="fc" id="L147">            t.setDescription(dto.getDescription());</span>
        }
<span class="fc" id="L149">        return teamRepo.save(t);</span>
    }

    /**
     * Delete a team. ADMIN-only.
     */
    public void delete(Long id) {
<span class="fc" id="L156">        requireAdmin();</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (!teamRepo.existsById(id)) {</span>
<span class="fc" id="L158">            throw new EntityNotFoundException(&quot;Team not found: &quot; + id);</span>
        }
<span class="fc" id="L160">        teamRepo.deleteById(id);</span>
<span class="fc" id="L161">    }</span>

    /**
     * Add a member to a team. Allowed for ADMIN, or MANAGER who is also a
     * member of the team.
     */
    public void addMember(Long teamId, String userId) {
<span class="fc" id="L168">        assertCanManageTeamMembers(teamId);</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (teamMemberRepo.existsByTeam_IdAndUser_Id(teamId, userId)) {</span>
<span class="fc" id="L171">            return;</span>
        }

<span class="fc" id="L174">        Team team = teamRepo.findById(teamId)</span>
<span class="fc" id="L175">                .orElseThrow(() -&gt; new EntityNotFoundException(&quot;Team not found: &quot; + teamId));</span>
<span class="fc" id="L176">        User user = userRepo.findById(userId)</span>
<span class="fc" id="L177">                .orElseThrow(() -&gt; new EntityNotFoundException(&quot;User not found: &quot; + userId));</span>

<span class="fc" id="L179">        TeamMember tm = new TeamMember();</span>
<span class="fc" id="L180">        tm.setTeam(team); // uses relationship field, not primitive ID</span>
<span class="fc" id="L181">        tm.setUser(user); // uses relationship field, not primitive ID</span>
<span class="fc" id="L182">        teamMemberRepo.save(tm);</span>
<span class="fc" id="L183">    }</span>

    /**
     * Remove a member from a team. Allowed for ADMIN, or MANAGER who is also a
     * member of the team.
     */
    public void removeMember(Long teamId, String userId) {
<span class="fc" id="L190">        assertCanManageTeamMembers(teamId);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (!teamMemberRepo.existsByTeam_IdAndUser_Id(teamId, userId)) {</span>
<span class="fc" id="L192">            return;</span>
        }
<span class="fc" id="L194">        teamMemberRepo.deleteByTeam_IdAndUser_Id(teamId, userId);</span>
<span class="fc" id="L195">    }</span>

    /* ===================== AuthZ Helpers ===================== */
private String currentUserId() {
<span class="fc" id="L199">    var auth = SecurityContextHolder.getContext().getAuthentication();</span>
<span class="fc bfc" id="L200" title="All 4 branches covered.">    if (auth == null || auth.getName() == null) {</span>
<span class="fc" id="L201">        throw new AccessDeniedException(&quot;Unauthenticated&quot;);</span>
    }
<span class="fc" id="L203">    String subject = auth.getName();</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (subject.contains(&quot;@&quot;)) {</span>
<span class="fc" id="L205">        return userRepo.findByEmail(subject)</span>
<span class="fc" id="L206">                .map(User::getId)</span>
<span class="pc" id="L207">                .orElseThrow(() -&gt; new AccessDeniedException(&quot;No user for email subject: &quot; + subject));</span>
    }
<span class="fc" id="L209">    return subject;</span>
}

    /**
     * True if current principal has ROLE_ADMIN.
     */
    private boolean isAdmin() {
<span class="fc" id="L216">        Authentication auth = SecurityContextHolder.getContext().getAuthentication();</span>
<span class="fc" id="L217">        return hasAnyAuthority(auth, &quot;ADMIN&quot;, &quot;ROLE_ADMIN&quot;);</span>
    }

    /**
     * True if current principal has ROLE_MANAGER.
     */
private boolean isManager() {
<span class="fc" id="L224">    Authentication auth = SecurityContextHolder.getContext().getAuthentication();</span>
<span class="fc" id="L225">    return hasAnyAuthority(auth, &quot;MANAGER&quot;, &quot;ROLE_MANAGER&quot;);</span>
}
 

    /**
     * Enforce ADMIN role.
     */
private void requireAdmin() {
<span class="fc bfc" id="L233" title="All 2 branches covered.">    if (!isAdmin()) {</span>
<span class="fc" id="L234">        throw new AccessDeniedException(&quot;Forbidden: requires ADMIN&quot;);</span>
    }
<span class="fc" id="L236">}</span>

    /**
     * Enforce a given high-level role (expects upper-case like &quot;MANAGER&quot;). It
     * maps to Spring Security authorities prefixed with &quot;ROLE_&quot;.
     */
private void requireRole(String roleUpper) {
<span class="fc" id="L243">    Authentication auth = SecurityContextHolder.getContext().getAuthentication();</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">    if (!hasAnyAuthority(auth, roleUpper, &quot;ROLE_&quot; + roleUpper)) {</span>
<span class="fc" id="L245">        throw new AccessDeniedException(&quot;Forbidden: requires &quot; + roleUpper);</span>
    }
<span class="fc" id="L247">}</span>
    /**
     * Check if a user entity has a given global role (roles stored as JSON
     * string). Example JSON: [&quot;employee&quot;,&quot;manager&quot;,&quot;admin&quot;]
     */

<span class="fc" id="L253">    private boolean isMemberOf(Long teamId, String userId) { return teamMemberRepo.existsByTeam_IdAndUser_Id(teamId, userId); }</span>

    private boolean hasGlobalRole(User u, String roleLower) {
<span class="fc" id="L256">        String roleRaw = u.getRole();</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (roleRaw == null) {</span>
<span class="fc" id="L258">            return false;</span>
        }

        try {
            // Si c'est du JSON (ex: [&quot;employee manager&quot;] ou [&quot;employee&quot;,&quot;manager&quot;])
<span class="fc" id="L263">            java.util.List&lt;String&gt; roles = objectMapper.readValue(</span>
<span class="fc" id="L264">                    roleRaw, new com.fasterxml.jackson.core.type.TypeReference&lt;java.util.List&lt;String&gt;&gt;() {</span>
            });
<span class="fc" id="L266">            return roles.stream()</span>
<span class="fc" id="L267">                    .filter(java.util.Objects::nonNull)</span>
<span class="fc" id="L268">                    .flatMap(r -&gt; java.util.Arrays.stream(r.split(&quot;[\\s,;|]+&quot;)))</span>
<span class="fc" id="L269">                    .anyMatch(t -&gt; roleLower.equalsIgnoreCase(t));</span>
<span class="fc" id="L270">        } catch (Exception ignore) {</span>
            // Pas JSON -&gt; on split directement
<span class="fc" id="L272">            return java.util.Arrays.stream(roleRaw.split(&quot;[\\s,;|]+&quot;))</span>
<span class="fc" id="L273">                    .anyMatch(t -&gt; roleLower.equalsIgnoreCase(t));</span>
        }
    }

    /**
     * Allow viewing team members if: - current user is ADMIN, or - current user
     * is a member of the team.
     */
private void assertCanViewTeamMembers(Long teamId) {
<span class="fc" id="L282">    String me = currentUserId();</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">    if (isAdmin()) return;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">    if (isMemberOf(teamId, me)) return;</span>
<span class="fc" id="L285">    throw new AccessDeniedException(&quot;Forbidden: not allowed to view members of this team&quot;);</span>
}

    /**
     * Allow managing team members if: - current user is ADMIN, or - current
     * user is MANAGER and a member of the team.
     */
private void assertCanManageTeamMembers(Long teamId) {
<span class="fc" id="L293">    String me = currentUserId();</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">    if (isAdmin()) return;</span>
<span class="pc bpc" id="L295" title="1 of 4 branches missed.">    if (isManager() &amp;&amp; isMemberOf(teamId, me)) return;</span>
<span class="fc" id="L296">    throw new AccessDeniedException(&quot;Forbidden: only ADMIN or MANAGER member of the team can modify members&quot;);</span>
}
    private static boolean hasAnyAuthority(Authentication auth, String... values) {
<span class="fc bfc" id="L299" title="All 4 branches covered.">        if (auth == null || auth.getAuthorities() == null) return false;</span>
<span class="fc" id="L300">        var expected = java.util.Set.of(values);</span>
<span class="fc" id="L301">        return auth.getAuthorities().stream().anyMatch(a -&gt; expected.contains(a.getAuthority()));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>